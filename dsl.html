<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>cfgfile: DSL for generation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cfgfile
   &#160;<span id="projectnumber">0.2.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">DSL for generation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>To simplify development with cfgfile was implemented cfgfile generator.</p>
<p>cfgfile generator this is generator of C++ header file from declarative description of the configuration file. By configuration file assumes configuration file in cfgfile format. In generated header will be declared all necessary classes of data and configuration tags.</p>
<p>For generation generator uses input configuration file in cfgfile format with following format:</p>
<p>Let's say you need data class with one std::string field then you should write following configuration file, for example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{forGeneration ifndefMacro</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  {namespace NamespaceName</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    {class NameOfTheClass</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;      {base tagNoValue}</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      {tagScalar</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        {valueType std::string}</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        {name fieldWithString}</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;      }</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    }</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  }</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --><p>Each configuration file for generator must has one {forGeneration} tag and all nested tags must be defined in this tag. {forGeneration} tag require string for #ifndef directive (include guard). There you can use {namespace} tag for generation data classes and tags in the specified C++ namespace. Namespaces can be nested. To declare data class and tag you should use {class} tag. {class} tag can has {base} tag to define base class of the configuration tag. {base} tag can has following values: tagNoValue, tagScalar, tagScalarVector. tagNoValue is not mandatory in this case. To define field in data class you can use following tags: {tagScalar} for scalar tag, {tagNoValue} for no-value tag, {tagScalarVector} for vector of scalar values, {tag} for already defined tag, {tagVectorOfTags} for vector of already defined tags.</p>
<p>{tagScalar}, {tagScalarVector} require C++ type defined in {valueType} tag. In this situation C++ type should be defined as string, that mean that, for example, unsigned int C++ type should be declared as "unsigned int".</p>
<p>{tag} and {tagVectorOfTags} require class name with namespace if it is exist. Class name should be defined in {valueType} tag. Namespace and class name should be separated with ::</p>
<p>All of field tags must have {name} tag with name of the field as value. If {base} defined with tagScalar or tagScalarVector then {valueType} and {name} must be defined. {base tagNoValue} is not necessary, if {base} is not defined then tagNoValue will be used as base class.</p>
<p>Fields can have {required} tag to mark field as required.</p>
<p>All of field tags can have {minMaxConstraint} or {oneOfConstraint} to define constraint for the field's value. {minMaxConstraint} require two tags {min value} and {max value}, and {oneOfConstraint} require list of values. For example, {minMaxConstraint {min 0} {max 100}}, {oneOfConstraint one two three}.</p>
<p>{base} and fields can have {defaultValue} tag to specify default value.</p>
<p>In the above example will be generated similar to the following header file.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>NamespaceName {</div><div class="line"></div><div class="line"><span class="keyword">class </span>NameOfTheClass {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  c_tors();</div><div class="line">  ~d_tor();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string &amp; fieldWithString() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> set_fieldWithString( <span class="keyword">const</span> std::string &amp; value );</div><div class="line">}; <span class="comment">// class NameOfTheClass</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// tag_NameOfTheClass</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> Trait &gt;</div><div class="line"><span class="keyword">class </span>tag_NameOfTheClass</div><div class="line">  :  <span class="keyword">public</span> <a class="code" href="classcfgfile_1_1tag__no__value__t.html">cfgfile::tag_no_value_t</a>&lt; Trait &gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  c_tors();</div><div class="line">  ~d_tor();</div><div class="line"></div><div class="line">  NameOfTheClass get_cfg() <span class="keyword">const</span>;</div><div class="line">}; <span class="comment">// class tag_NameOfTheClass</span></div><div class="line"></div><div class="line">} <span class="comment">// namespace NamespaceName</span></div></div><!-- fragment --><p>Additionally you can use custom data structures and tags in the generator. For this you can use {globalInclude string} and {relativeInclude string} tags. When using such includes in C++ code will be added corresponding include directives. And checking of classes' and namespaces' names will be turned off. And one more restriction is that that class's name for tag must be equal to tag_ + Name, i.e. if data structure names Data then class for tag must be named tag_Data and be placed in the same namespace as Data class/ structure. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
